\section{Policy Modules}
\label{lance-sec-policies}

Policy modules provide an interface through 
which applications can tune the operation of the Lance optimizer.
Since policy modules are loaded into the system
at the base station, they can be modified at any time without 
necessitating reprogramming of the sensor nodes themselves.
In this section we provide a general discussion of policy modules and
provide a series of examples of various policies that can be implemented
through this feature. 

\subsection{Definitions}

A policy module is an application-supplied function that takes as input an
ADU summary tuple $a_i = \{ i, n_i, t_i, d_i, \bar{c}_i, s_i, v_i \}$ and
produces a new tuple $a'_i$ with a possibly modified value $v'_i$.  Policy
modules run at the base station, can maintain internal state, and operate
with global knowledge of the ADUs stored in the network. 

A series of policy modules $\{m_1, m_2, ... m_n\}$ are composed into a 
linear chain, which is passed the 
ADU information extracted from the ADU summary messages received at
the base station. The first policy module in the chain is responsible
for assigning the initial value $v_i$ to the ADU based on the summary 
information $s_i$ calculated by the sensor node. 
The final ADU value produced by the chain is used as input to 
Lance's optimizer for the purpose of scheduling ADUs for download.

Lance requires that policy modules be efficient in that
they can process the stream of ADU summaries received from the
network in real time. In practice this is not difficult to accomplish,
as the rate of ADU summary reception is modest, and the base
station (typically a PC or laptop) is assumed to have adequate
resources. For example, a 100-node network with an ADU size of 60~sec 
would receive an ADU summary every 600~msec. Typical policy modules
take a small fraction of this time to run. 

One of the main benefits of policy modules is that they permit 
significant changes to the network's behavior {\em without requiring
changes to the node-level summarization function}. Changing the
latter would typically involve reprogramming sensor nodes. 
In the field, it is often undesirable to reprogram the network 
except when absolutely necessary, and in many cases it is difficult to 
reach sensor nodes physically once deployed. Although systems such as 
Deluge~\cite{deluge} permit over-the-air reprogramming, 
any changes to the sensor node software could result in unexpected
failures that can be very difficult to debug without manual intervention. 
On the other hand, introducing new policy modules at the base station 
is relatively straightforward, and can be quickly reversed without 
risking sensor node failures. 

\subsection{Example policy modules}
\label{lance-sec-example-policies}

\begin{figure}[t]
\label{lance-fig-policymodules}
\begin{center}
\begin{small}
\begin{tabular}{|l|l|} \hline
{\em Policy module} & {\em Description} \\ \hline
{\tt filter} & Set ADUs below threshold to zero value \\
{\tt boost} & Set ADUs above threshold to max value \\
{\tt timespread} & Dilate ADU values across time \\
{\tt spacespread} & Dilate ADU values across space \\
{\tt adjust} & Add or subtract offset to ADU value \\
{\tt smooth} & Apply low-pass filter to remove noise \\
{\tt debias} & Median filter DC debiasing \\
{\tt correlated} & Boost values for correlated events \\
{\tt costfilter} & Filter ADUs above cost threshold \\ \hline
\end{tabular}
\end{small}
\end{center}
\caption{\textbf{Standard policy modules provided by Lance.}}
\end{figure}

Policy modules can be used to encapsulate a wide range of data collection
goals, and make it easy to customize Lance's behavior for specific
applications. We provide a standard toolkit of general-purpose policy
modules, summarized in Figure~\ref{lance-fig-policymodules}.  Application
developers are free to implement their own modules as well.  By composing
modules in a linear chain, it is easy to implement various behaviors without
requiring a general-purpose ``policy language.'' 

{\bf Value thresholding:}
{\tt filter} is perhaps the simplest example of a policy module that 
filters out ADUs with a value below a given threshold $T$ by
setting their values to zero.
%\[p'_i = 
%  \left\{ \begin{array}{ll} 
%          p_i & \mbox{if $p_i \geq T$}\\
%          0 & \mbox{otherwise} \end{array} \right. \]
Setting $v'_i = 0$ prevents an ADU from being considered for download by the
optimizer.  This type of filtering can be used to force a drop of low-valued
data. Conversely, the {\tt boost} policy module sets the value for an ADU
above a given threshold to the maximum value, ensuring it will be downloaded
as soon as it is feasible.

{\bf Value adjustment and noise removal:} 
Policy modules can be used to remove the effects of noise or correct 
for node-level value bias, for example, based on poor sensor 
calibration or differences in site response. Moreover, since each node 
computes the ADU summary based only on local sensor data, it may be 
necessary to normalize the ADU values in order to compare 
values across nodes. 

{\tt adjust} adds or subtracts a node-specific offset to each ADU
value to correct for differences in sensor calibration.{\tt smooth}
applies a simple low-pass filter on the raw ADU values to remove
spikes caused by spurious sensor noise.
Likewise, {\tt debias} is intended to remove
sensor-specific DC~bias from the ADU values.
{\tt debias} computes the median ADU value for a given node over 
a time window. It then subtracts the median from each ADU value before 
passing it along to the next module in the chain. 

Likewise, when a sensor network contains
multiple sensors with varying sensitivity, it is natural to
prioritize data from more sensitive instruments. In cases where networks are
deployed to monitor fixed physical phenomena, it may be desirable to
prioritize data from nodes located close to the phenomena being
observed. The {\tt adjust} module can be used to scale
raw ADU values based on a sensor's location, SNR, or other attributes.

{\bf Value dilation:} 
Another useful policy is to dilate a high (or
low) ADU value observed in one ADU across different ADUs sampled
at different times or different nodes. This can be used to achieve
greater spatial or temporal coverage of an interesting signal
observed at one or more nodes. The {\tt timespread} detects ADUs with
a value above some threshold $T$ and 
assigns the same value to those ADUs sampled just before and just
after.
%\[p'_{i-1} =
%  \left\{ \begin{array}{ll} 
%          p_i & \mbox{if $p_i \geq T$}\\
%          p'_{i-1} & \mbox{otherwise} \end{array} \right. 
%\]
%Similarly for $p'_{i+1}$. 

Likewise, the {\tt spacespread} module groups ADUs from across multiple
nodes into time windows and assigns the maximum ADU value to all
ADUs in that window.  Define a window $W(t,\delta)$ as the set of ADUs
such that $t-\delta \leq t_i \leq t+\delta$ where $t$ represents the
center of the window and $\delta$ the window size. {\tt spacespread}
determines the maximum ADU in the window $v^* = \arg_{i \in W} \max v_i$
and sets $v'_i = v^{*}$ for each ADU in $W$. 

{\bf Correlated event detection:}
The {\tt correlated} module is used to 
select for ADUs that appear to represent a correlated
event observed across the entire sensor network. 
{\tt correlated} counts the number of ADUs within a time window
$W(t,\delta)$ with a nonzero ADU value.
If at least $k$ ADUs meet this criterion, we assume that there is 
a correlated stimulus, and the values for all ADUs in 
the set are passed through.  Otherwise, we filter out the ADUs in 
the window by setting $v'_i = 0$ for each ADU in $W$.

As an example of composing policy modules to implement an interesting
behavior, consider the chain
\[
\mathit{filter}(T)\rightarrow\mathit{correlated}(k)\rightarrow\mathit{spacespread}
\]
This policy filters incoming values, rejects time-correlated sets 
with fewer than $k$ ADUs above the threshold, and assigns the max
value across the set to all ADUs. This can be useful in 
systems that wish to perform collection of time-correlated data, but
avoid spurious high-value data from just a few nodes. 
This policy is similar to the volcanic earthquake detector reported 
in~\cite{volcano-osdi06}, expressed as a simple policy module chain.

{\bf Cost-based filtering:}
Lance's optimizer considers both the cost of ADUs as well as their
application-assigned values when making download scheduling decisions.
The cost vector $\bar{c}_i$ is also available to the policy module
chain, allowing policy modules to perform their own adjustments to
the ADU value according to cost, permitting applications to augment 
Lance's own policies for energy scheduling. 
For example, the {\em costfilter} policy module filters out ADUs with
a total energy cost $\sum_j c_i^j$ greater than some threshold; this
ensures that the network avoids expending an arbitrary amount of
energy to download a given ADU (regardless of its data value). 
Policy modules give applications a great deal of control over energy 
usage to complement Lance's own energy scheduling policy.

